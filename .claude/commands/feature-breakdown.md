# 기능 구현 분해 커스텀 커맨드

## 사용 방법
구현하고 싶은 기능을 입력하면, 체계적으로 작은 단위로 분해된 실행 계획을 제공받을 수 있습니다.

## 구현하고 싶은 기능

$ARGUMENTS

---

## 구조 분석 가이드

### 1. 기능 분석
입력된 기능의 본질을 파악하세요:
- **사용자 가치**: 이 기능이 최종 사용자에게 제공하는 가치는?
- **핵심 요구사항**: 반드시 구현되어야 하는 필수 기능은?
- **부가 요구사항**: 있으면 좋지만 필수는 아닌 기능은?
- **제약 조건**: 기술적, 시간적, 비즈니스적 제약은?
- **성공 기준**: 이 기능이 "완료"되었다고 판단하는 기준은?

### 2. 아키텍처 분해
기능을 구성하는 기술적 계층을 분석하세요:
- **데이터 계층**: 필요한 데이터 모델, 타입 정의, 스키마 변경
- **비즈니스 로직 계층**: 핵심 로직, 유틸리티 함수, 훅
- **API 계층**: 엔드포인트, 서버 액션, 외부 API 연동
- **UI 계층**: 컴포넌트 구조, 페이지, 레이아웃 변경
- **상태 관리**: 로컬 상태, 전역 상태, 캐싱 전략

### 3. 작업 분해
각 계층을 실행 가능한 단위 작업으로 나누세요. 각 작업은:
- **단일 책임**: 한 가지 명확한 목표만 가질 것
- **검증 가능**: 완료 여부를 객관적으로 판단할 수 있을 것
- **적절한 크기**: 1~2시간 내 완료 가능한 크기일 것
- **명확한 산출물**: 작업 결과로 생성/수정되는 파일이 명확할 것

### 4. 의존성 관계
작업 간의 선후 관계를 명확히 하세요:
- **선행 작업**: 이 작업 전에 완료되어야 하는 작업
- **후행 작업**: 이 작업 완료 후 시작 가능한 작업
- **병렬 작업**: 동시에 진행 가능한 독립적인 작업
- **블로킹 포인트**: 전체 진행을 막을 수 있는 병목 지점

### 5. 검증 계획
각 단계별 품질 확인 방법을 정의하세요:
- **단위 검증**: 개별 작업 완료 시 확인 방법
- **통합 검증**: Phase 완료 시 전체 동작 확인 방법
- **회귀 검증**: 기존 기능에 영향이 없는지 확인 방법
- **사용자 검증**: 최종 사용자 관점에서 기능 동작 확인

### 6. 진행 추적
구현 과정을 모니터링하는 방법을 설정하세요:
- **마일스톤**: 주요 완료 지점 정의
- **체크포인트**: 각 Phase 완료 시 상태 확인
- **리스크 지표**: 일정 지연이나 기술적 문제 조기 발견 기준

### 7. 배포 전략
완성된 기능을 안전하게 배포하는 방법을 계획하세요:
- **배포 단위**: 한 번에 배포할 범위 (전체/단계별)
- **롤백 계획**: 문제 발생 시 이전 상태로 복구 방법
- **기능 플래그**: 점진적 롤아웃이 필요한 경우 전략

---

## 요청사항

1. **코드베이스 탐색**: 관련 파일을 먼저 확인하고 분석에 반영하세요
2. **구체적인 파일 명시**: 각 작업에서 수정/생성할 파일 경로를 명시하세요
3. **점진적 구현**: 각 Phase 완료 시 동작하는 상태를 유지하도록 계획하세요
4. **검증 방법 포함**: 각 작업의 완료를 어떻게 확인할 수 있는지 명시하세요
5. **리스크 식별**: 잠재적 문제점과 대응 방안을 미리 파악하세요

---

## 출력 형식

### 📋 기능 요약

| 항목 | 내용 |
|------|------|
| 기능명 | [기능 이름] |
| 사용자 가치 | [최종 사용자에게 제공하는 가치] |
| 핵심 요구사항 | [필수 구현 항목] |
| 부가 요구사항 | [선택적 구현 항목] |
| 성공 기준 | [완료 판단 기준] |

### 🏗️ 아키텍처 분석

| 계층 | 변경 사항 | 관련 파일 |
|------|----------|----------|
| 데이터 | [변경 내용] | `[파일 경로]` |
| 비즈니스 로직 | [변경 내용] | `[파일 경로]` |
| API | [변경 내용] | `[파일 경로]` |
| UI | [변경 내용] | `[파일 경로]` |
| 상태 관리 | [변경 내용] | `[파일 경로]` |

### 🔍 현재 상태 분석

- **재사용 가능한 코드**: [기존 코드 중 활용할 수 있는 것]
- **수정 필요한 코드**: [변경이 필요한 기존 코드]
- **신규 생성 필요**: [새로 만들어야 할 파일/컴포넌트]

### 🔨 실행 계획

#### Phase 1: [Phase 이름]
**목표**: [이 Phase에서 달성할 목표]

| 순서 | 작업 | 파일 | 완료 기준 |
|-----|------|------|----------|
| 1-1 | [작업명] | `[파일 경로]` | [완료 기준] |
| 1-2 | [작업명] | `[파일 경로]` | [완료 기준] |

**Phase 1 검증**: `[검증 명령어 또는 방법]`

#### Phase 2: [Phase 이름]
**목표**: [이 Phase에서 달성할 목표]

| 순서 | 작업 | 파일 | 완료 기준 |
|-----|------|------|----------|
| 2-1 | [작업명] | `[파일 경로]` | [완료 기준] |
| 2-2 | [작업명] | `[파일 경로]` | [완료 기준] |

**Phase 2 검증**: `[검증 명령어 또는 방법]`

#### Phase 3: [Phase 이름]
**목표**: [이 Phase에서 달성할 목표]

| 순서 | 작업 | 파일 | 완료 기준 |
|-----|------|------|----------|
| 3-1 | [작업명] | `[파일 경로]` | [완료 기준] |
| 3-2 | [작업명] | `[파일 경로]` | [완료 기준] |

**Phase 3 검증**: `[검증 명령어 또는 방법]`

### 🔗 의존성 다이어그램

```
[1-1] → [1-2] → [2-1]
                  ↓
        [2-2] → [3-1] → [3-2]
```

**병렬 실행 가능**: [동시 진행 가능한 작업 그룹]
**블로킹 포인트**: [병목이 될 수 있는 작업]

### 📍 마일스톤 및 진행 추적

| 마일스톤 | 완료 조건 | 체크포인트 |
|---------|----------|-----------|
| M1: [이름] | [조건] | Phase 1 완료 |
| M2: [이름] | [조건] | Phase 2 완료 |
| M3: [이름] | [조건] | 전체 완료 |

### ⚠️ 리스크 및 대응 방안

| 리스크 | 영향도 | 대응 방안 |
|-------|-------|----------|
| [리스크 설명] | 높음/중간/낮음 | [대응 방법] |

### 🚀 배포 전략

- **배포 단위**: [전체 배포 / Phase별 배포]
- **배포 전 체크**: [배포 전 확인 사항]
- **롤백 계획**: [문제 시 복구 방법]

### ✅ 최종 검증 체크리스트

- [ ] 핵심 기능 동작 확인
- [ ] 엣지 케이스 처리 확인
- [ ] 기존 기능 회귀 테스트
- [ ] TypeScript 컴파일 에러 없음
- [ ] Lint 에러 없음
- [ ] 빌드 성공
- [ ] 반응형 디자인 확인 (UI 변경 시)
